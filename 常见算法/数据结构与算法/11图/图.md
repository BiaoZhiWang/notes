#### 图在作用
> 如交通流量等运输相关的建模，计算机网络的建模

##### 图的相关概念
> 图是边与顶点的集合。
> 顶点可以有权重，也可以称为成本. 如果顶点对是有序的，则可以称为有向图, 反之为无序图
> 路径长度由路径中第一个顶点到最后一个顶点之间的变的数量来表示。 指向自身的顶点组成的路径称为环
> 圈指至少一条边的路径，同时第一个顶点与最后一个顶点为同一个顶点。 没有重复顶点的全为简单圈。 除了第一个与最后一个顶点外，路径其它顶点有重复的圈称为平凡圈

> 如果两个顶点之间有路径，那么两个顶点为强连通的，反之亦然。

##### 如何建立对图的表述
> 一个类来产生顶点， 包含顶点标识与该顶点是否被访问过的布尔值。
```
  function Vertex(label) {
    this.label = label;
  }
```
> 由于一个顶点可能有多条边，二叉树的表现形式不适合。对于边的表述可以使用邻接表
> 边的表述： 为由顶点的相邻顶点构成的数组， 同时顶点值为该数组的索引。
> 从而表述图使用的是一个二维数组。顶点值代表索引，相当于顶点，而索引值为一个数组，表示边的关系。

##### 图的两种基础搜索
+ 1、深度优先算法
> 从路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续下一条路径，知道到达最后的顶点，如此循环，直至所有边遍历完
> 为Graph类添加一个数组，用来存储已经访问过的顶点.

+ 2、广度优先遍历
> 从一个顶点开始，逐层遍历

##### 查找最短路径
+ 1、广度优先搜索最短路径
> 先查找两顶点是否有一条单边路径，然后查找两条边的路径。一次类推

##### 拓扑排序
> 拓扑排序会对有向图的所有顶点进行排序，是有向边从前面的顶点指向后面的顶点
> 拓扑排序与深度优先搜索类似: 会访问当前顶点邻接表中的所有相邻顶点，知道这个列表穷尽时，才将当前顶点压入栈中

  - 如何实现拓扑排序算法
  >第一个函数: topSort()，会设置排序进程并调用辅助函数topSortHelper();
  > topSortHelper: 将当前顶点标记为已访问，递归访问当前顶点邻接表中的每个相邻顶点,标记这些顶点为已访问。最后将顶点压入栈